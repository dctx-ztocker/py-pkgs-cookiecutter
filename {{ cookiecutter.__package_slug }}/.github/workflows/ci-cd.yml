###############################
# CI/CD for {{ cookiecutter.__package_slug }}
#
# Overview
# - CI: Install deps, run tests, upload coverage
# - CD: (develop/staging/main) Version bump on main via semantic-release, build & push Docker image to ECR
#
# Required repository configuration
# - Variables:
#   - AWS_REGION (e.g., us-east-1)
#   - MAIN_ORGANIZATION_ID / STAGING_ORGANIZATION_ID / DEVELOP_ORGANIZATION_ID (if using CodeArtifact)
# - Secrets:
#   - DEVELOP_AWS_ACCESS_KEY_ID / DEVELOP_AWS_SECRET_ACCESS_KEY (used for ECR in this setup)
#   - GH_TOKEN (for semantic-release on main)
#   - CODECOV_TOKEN (for CI coverage upload)
###############################

name: ci-cd

on:
  push:
    branches:
      - "main"
    paths:
      - "src/**"
      - ".github/**"
      - ".build/**"
      - poetry.lock
      - pyproject.toml
      - tests/**
      - .github/workflows/ci-cd.yml

env:
  # General
  PACKAGE_NAME: "{{ cookiecutter.__package_slug }}"
  PYTHON_VERSION: "{{ cookiecutter.python_version }}"
  MIN_COVERAGE: 0

  # Feature flags resolved from cookiecutter
  # include_github_actions: no | ci | ci+cd
  # deploy_target: none | codeartifact | ecr | both
  {% raw %}# Jinja renders below at generation time{% endraw %}
  {% if cookiecutter.deploy_target in ["ecr", "both"] %}
  ENABLE_ECR: true
  {% else %}
  ENABLE_ECR: false
  {% endif %}

  {% if cookiecutter.deploy_target in ["codeartifact", "both"] %}
  ENABLE_CODEARTIFACT: true
  {% else %}
  ENABLE_CODEARTIFACT: false
  {% endif %}

  # ECR repo name
  ECR_REPOSITORY: "{{ cookiecutter.ecr_repository_name }}"

  # CodeArtifact settings
  DOMAIN_NAME: "{{ cookiecutter.codeartifact_domain_name }}"
  CODEARTIFACT_REPOSITORY: "{{ cookiecutter.codeartifact_repository_name }}"

  # Docker
  DOCKERFILE_PATH: "{{ cookiecutter.dockerfile_path | default('.build/Dockerfile') }}"
  DOCKER_BUILD_CONTEXT: "{{ cookiecutter.docker_build_context | default('.') }}"

jobs:
  continuous-integration:
    # Set up operating system
    runs-on: ubuntu-latest

    # Define job steps
    steps:
      - name: Check-out repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "{% raw %}${{ env.PYTHON_VERSION }}{% endraw %}"

      - name: Install poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-create: true

      - name: Install package dependencies
        run: poetry install

      - name: Run tests with pytest
        run: |
          poetry run pytest tests/ \
            --cov={{ cookiecutter.__package_slug }} \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under={% raw %}${{ env.MIN_COVERAGE }}{% endraw %}

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.xml
        env:
          CODECOV_TOKEN: "{% raw %}${{ secrets.CODECOV_TOKEN }}{% endraw %}"

  {% if cookiecutter.include_github_actions == 'ci+cd' and cookiecutter.deploy_target != 'none' %}
  continuous-deployment:
    permissions:
      id-token: write
      contents: write
    needs: continuous-integration
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Check-out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "{% raw %}${{ env.PYTHON_VERSION }}{% endraw %}"

      - name: Install poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-create: true

      - name: Install package dependencies
        run: poetry install --with dev

      - name: Create release and update version
        if: github.ref == 'refs/heads/main'
        id: semantic-release
        run: |
          poetry run semantic-release -v version --skip-build
        env:
          GH_TOKEN: "{% raw %}${{ secrets.GH_TOKEN }}{% endraw %}"

      - name: Get current version
        id: version
        run: |
          VERSION=$(poetry version --short)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Set Organization ID
        id: org-id
        run: |
          ORG_ID="{% raw %}${{ vars.DEVELOP_ORGANIZATION_ID }}{% endraw %}"
          if [ -z "$ORG_ID" ]; then
            echo "Missing DEVELOP_ORGANIZATION_ID repository variable"; exit 1;
          fi
          echo "org_id=${ORG_ID}" >> $GITHUB_OUTPUT
          echo "Organization ID: $ORG_ID"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: "{% raw %}${{ secrets.DEVELOP_AWS_ACCESS_KEY_ID }}{% endraw %}"
          aws-secret-access-key: "{% raw %}${{ secrets.DEVELOP_AWS_SECRET_ACCESS_KEY }}{% endraw %}"
          aws-region: "{% raw %}${{ vars.AWS_REGION }}{% endraw %}"

      # ==========================
      # CodeArtifact (optional)
      # ==========================
      - name: Get CodeArtifact Authorization Token
        if: env.ENABLE_CODEARTIFACT == 'true'
        id: codeartifact-token
        run: |
          TOKEN=$(aws codeartifact get-authorization-token \
            --domain "{% raw %}${{ env.DOMAIN_NAME }}{% endraw %}" \
            --domain-owner "{% raw %}${{ steps.org-id.outputs.org_id }}{% endraw %}" \
            --region "{% raw %}${{ vars.AWS_REGION }}{% endraw %}" \
            --query authorizationToken --output text)
          if [ -z "$TOKEN" ]; then
            echo "Failed to get CodeArtifact token"; exit 1;
          fi
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Get CodeArtifact Repository Endpoint
        if: env.ENABLE_CODEARTIFACT == 'true'
        id: codeartifact-endpoint
        run: |
          ENDPOINT=$(aws codeartifact get-repository-endpoint \
            --domain "{% raw %}${{ env.DOMAIN_NAME }}{% endraw %}" \
            --domain-owner "{% raw %}${{ steps.org-id.outputs.org_id }}{% endraw %}" \
            --repository "{% raw %}${{ env.CODEARTIFACT_REPOSITORY }}{% endraw %}" \
            --format pypi \
            --region "{% raw %}${{ vars.AWS_REGION }}{% endraw %}" \
            --query repositoryEndpoint --output text)
          if [ -z "$ENDPOINT" ]; then
            echo "Failed to get CodeArtifact endpoint"; exit 1;
          fi
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT

      - name: Configure Poetry for CodeArtifact
        if: env.ENABLE_CODEARTIFACT == 'true'
        run: |
          poetry config repositories.codeartifact {% raw %}${{ steps.codeartifact-endpoint.outputs.endpoint }}{% endraw %}simple/
          poetry config http-basic.codeartifact aws {% raw %}${{ steps.codeartifact-token.outputs.token }}{% endraw %}

      - name: Build package distributions
        if: env.ENABLE_CODEARTIFACT == 'true'
        run: |
          poetry build --format wheel
          poetry build --format sdist
          ls -la dist/

      - name: Publish to CodeArtifact
        if: env.ENABLE_CODEARTIFACT == 'true'
        run: |
          WHEEL_PATH=$(find dist -name "*.whl")
          SDIST_PATH=$(find dist -name "*.tar.gz")
          poetry run twine upload \
            --repository-url {% raw %}${{ steps.codeartifact-endpoint.outputs.endpoint }}{% endraw %} \
            --username aws \
            --password {% raw %}${{ steps.codeartifact-token.outputs.token }}{% endraw %} \
            $WHEEL_PATH $SDIST_PATH

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        if: env.ENABLE_ECR == 'true'
        run: |
          if [ ! -f "{% raw %}${{ env.DOCKERFILE_PATH }}{% endraw %}" ]; then
            echo "Dockerfile not found at {% raw %}${{ env.DOCKERFILE_PATH }}{% endraw %}. Skipping Docker build and push.";
            exit 0;
          fi

          ECR_REGISTRY={% raw %}${{ steps.login-ecr.outputs.registry }}{% endraw %}
          ECR_REPOSITORY={% raw %}${{ env.ECR_REPOSITORY }}{% endraw %}
          IMAGE_TAG={% raw %}${{ steps.version.outputs.version }}{% endraw %}

          echo "Building image with tag: ${IMAGE_TAG}"
          docker build \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f {% raw %}${{ env.DOCKERFILE_PATH }}{% endraw %} {% raw %}${{ env.DOCKER_BUILD_CONTEXT }}{% endraw %}

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

          # Update latest tag
          aws ecr batch-delete-image --repository-name $ECR_REPOSITORY --image-ids imageTag=latest || true
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

      - name: Clean up resources
        if: always()
        run: |
          poetry env remove --all || true
          docker system prune -f
  {% endif %}
